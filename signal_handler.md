# Signal Handlers:

* Signals are software interrupts that notify a process about asynchronous events, such as keyboard interrupts (`SIGINT`), division by zero (`SIGFPE`), and termination requests (`SIGTERM`).
* A **signal handler** is a function that the process registers to handle a specific signal.
  When the signal is received, the process pauses its execution and invokes the registered handler.

# Sigaction and Sigaction-Installed Handlers:

* The `sigaction` system call is a more versatile way to register signal handlers compared to the older `signal` function.
  It allows you to specify various options, including:
    * The signal to handle
    * The new handler function
    * An optional "old" handler to remove
    * A set of flags controlling handler behavior (e.g., `SA_SIGINFO` for more information in the handler arguments)
* A **sigaction-installed handler** refers to a handler registered using the `sigaction` system call, as opposed to the simpler `signal` function.

# Async-Signal-Safety:

* A function is considered **async-signal-safe** if it can be called safely from a signal handler without introducing undefined behavior.
  This means the function must meet several criteria:
    * **Reentrant:**                      It must be able to be called recursively, even if it's already being called within another signal handler.
    * **Uses reentrant data structures:** It must avoid using global variables or other shared resources that could be modified by other threads or signal handlers concurrently.
    * **Avoids I/O operations:**          I/O operations like `printf`, `std::cout`, or `std::cerr` can be interrupted by signals, leading to unexpected behavior or data corruption.


# Question: Sigaction-installed async signal handlers shouldnâ€™t write any output - directly or indirectly - using printf, std::cout or std::cerr?
This is true.
The functions printf, std::cout, and std::cerr are not async-signal-safe.
Using them in a signal handler can result in undefined behavior.

**The Statement:**
The statement "Sigaction-installed async signal handlers shouldn't write any output - directly or indirectly - using `printf`, `std::cout`, or `std::cerr`" is **true**. Here's why:

1. **Non-Reentrancy:**
   These functions typically use global variables or other shared resources internally, making them non-reentrant.
   If they're called from a signal handler while another thread is also using them, undefined behavior can occur.

2. **Interruptions:**
   I/O operations can be interrupted by signals mid-execution, leaving the output stream in an inconsistent state and potentially corrupting data.

3. **Deadlocks:**
   If the signal handler tries to acquire a lock or other resource that's already held by another thread (e.g., due to I/O operations), it can lead to deadlocks, where both threads are waiting for each other indefinitely.

## Example:

```c++
#include <iostream>
#include <signal.h>

void signal_handler(int sig) {
    std::cout << "Signal " << sig << " received!" << std::endl; // Unsafe: Using std::cout from a signal handler
}

int main() {
    struct sigaction sa;                                        // Register signal handler using sigaction
    sa.sa_handler = signal_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGINT, &sa, NULL);                               // Handle SIGINT (Ctrl+C)

    while (true) {
        std::cout << "Doing something..." << std::endl;         // Simulate some work the program is doing
        sleep(1);                                               // Sleep for 1 second
    }

    return 0;
}
```
## Explanation of the Signal Handler Code and why it is unsafe:

The provided code demonstrates how to register a signal handler using the `sigaction` system call to handle the `SIGINT` signal (typically generated by pressing Ctrl+C).
Here's a breakdown of each line:

**1. `struct sigaction sa;`:**

* This line declares a variable `sa` of type `struct sigaction`.
  This structure holds information needed for registering a signal handler using `sigaction`.

**2. `sa.sa_handler = signal_handler;`:**

* This line sets the `sa_handler` member of the `sa` structure to point to the function `signal_handler`.
  This function will be invoked when the `SIGINT` signal is received.

**3. `sigemptyset(&sa.sa_mask);`:**

* This line initializes the `sa_mask` member of the `sa` structure.
  This member is an `sigset_t` object that specifies a set of signals that should be temporarily blocked while the signal handler is executing.
  The `sigemptyset` function sets the mask to an empty set, meaning no signals are blocked during handler execution.

**4. `sa.sa_flags = 0;`:**

* This line initializes the `sa_flags` member of the `sa` structure. This member allows specifying additional options for the signal handler.
  Here, it's set to 0, meaning no special flags are used.

**5. `sigaction(SIGINT, &sa, NULL);`:**

* This line is the core of the code, performing the actual registration of the signal handler.
    * `SIGINT`: This is the signal number for which the handler is being registered. (Ctrl+C typically generates this signal).
    * `&sa`: This is the address of the `sa` structure containing the handler information.
    * `NULL`: This argument is used to specify an "old handler" to remove, but it's set to `NULL` here as no previous handler needs to be replaced.

This call to `sigaction` effectively registers the `signal_handler` function to be invoked whenever the process receives the `SIGINT` signal.

### In this example, using `std::cout` within the signal handler is **unsafe*** because:
* It's not reentrant, potentially causing issues if the handler is called recursively or concurrently from other threads.
* The ongoing `std::cout` operation could be interrupted by the signal, leading to undefined behavior or data corruption.

## Alternatives:
* **Use async-signal-safe functions:**
  C provides a set of async-signal-safe functions, such as `write` and `fputs`, that can be used for limited output from signal handlers.
  However, use caution and carefully manage state within these functions to avoid issues.

* **Log to a file:**
  If logging is necessary, consider writing to a file using async-signal-safe methods, but be mindful of thread safety and resource management.

* **Queue messages:**
  Instead of directly writing output, the handler can queue messages in a thread-safe queue to be processed later by a dedicated thread that's safe to use I/O functions.

Remember that even with alternatives, exercising caution and carefully designing your signal handlers is crucial to avoid unexpected behavior and maintain program stability.
