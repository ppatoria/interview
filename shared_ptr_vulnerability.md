<style>
/* Solarized Light color theme */
body {
background-color: #fdf6e3;
color: #657b83;
}

h1 {
color: #268bd2;
font-size: 22px;
font-weight: bold;
margin-top: 30px;
}

h2 {
color: #268bd2;
font-size: 16px;
font-weight: bold;
margin-top: 20px;
margin-bottom: 10px;
}

h3 {
color: #268bd2;
font-size: 10px;
font-weight: bold;
margin-top: 20px;
margin-bottom: 10px;
}

p {
color: #657b83;
}

code {
background-color: #eee8d5;
color: #657b83;
font-family: Consolas, monospace;
padding: 2px 4px;
border-radius: 4px;
}

pre {
background-color: #eee8d5;
color: #657b83;
padding: 10px;
border-radius: 4px;
overflow-x: auto;
}

/* Additional styling for FAQ sections */
h2[id^="scenario"] {
color: #268bd2;
font-weight: bold;
font-size: 18px;
}

/* Table of Contents (TOC) */
#toc {
position: fixed;
top: 0;
left: 0;
width: 200px;
padding: 10px;
background-color: #eee8d5;
}

/* Adjust the content area to make space for TOC */
body {
margin-left: 220px;
}
</style>


<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
**Table of Contents**

- [Shared Pointer](#shared-pointer)
    - [Ownership:](#ownership)
    - [Borrowing:](#borrowing)
    - [Lifetime:](#lifetime)
- [Control Block](#control-block)
    - [Reference Count:](#reference-count)
    - [Managed Object Pointer:](#managed-object-pointer)
    - [Deleter Function Pointer (optional):](#deleter-function-pointer-optional)
    - [Multiple `std::shared_ptr` instances can share the same control block.](#multiple-stdshared_ptr-instances-can-share-the-same-control-block)
    - [The control block is responsible for deleting the managed object and freeing the associated memory.](#the-control-block-is-responsible-for-deleting-the-managed-object-and-freeing-the-associated-memory)
- [Concurrent Updates to the `shared_ptr` itself (i.e. during reassigning or changing shared ownership) :](#concurrent-updates-to-the-shared_ptr-itself-ie-during-reassigning-or-changing-shared-ownership-)
    - [Description](#description)
    - [Example](#example)
    - [Example:](#example)
    - [Data races or Memory Leak:](#data-races-or-memory-leak)
    - [Solution](#solution)
- [Accessing a destroyed object while other threads still hold references:](#accessing-a-destroyed-object-while-other-threads-still-hold-references)
    - [Example:](#example-1)
    - [Undefined behavior:](#undefined-behavior)
    - [Solution:](#solution)
- [Circular References or Circular dependencies:](#circular-references-or-circular-dependencies)
    - [Example:](#example-2)
    - [Memory Leak:](#memory-leak)
    - [Solution:](#solution-1)
- [Incorrect usage with raw pointers:](#incorrect-usage-with-raw-pointers)
    - [Example:](#example-3)
- [Inappropriate use in performance-critical code:](#inappropriate-use-in-performance-critical-code)
- [Misuse of custom deleters:](#misuse-of-custom-deleters)
    - [Example:](#example-4)
        - [Memory Leak:](#memory-leak-1)
        - [Undefined Behavior:](#undefined-behavior)

<!-- markdown-toc end -->



# Shared Pointer
## Ownership:
- `std::shared_ptr` represents *shared ownership* of a dynamically allocated object.
It allows multiple `std::shared_ptr` instances to point to the same object.
- When a `std::shared_ptr` is created, it takes ownership of the object by incrementing the reference count in its control block.
- The reference count keeps track of the number of `std::shared_ptr` instances pointing to the object.
As long as the reference count is greater than zero, the object remains alive.

## Borrowing:
- `std::shared_ptr` allows borrowing or sharing of ownership.
Multiple `std::shared_ptr` instances can be created from an existing `std::shared_ptr` to share ownership of the object.
- When a new `std::shared_ptr` is created from an existing one,
both the original and the new `std::shared_ptr` point to the same object,
and the reference count is incremented.
- Each `std::shared_ptr` instance can access the object and modify its contents if necessary.

## Lifetime:
- The lifetime of the object managed by `std::shared_ptr` is tied to the lifetime of the `std::shared_ptr` instances that own it.
- When the last `std::shared_ptr` owning the object goes out of scope or is explicitly reset, the reference count is decremented.
- If the reference count reaches zero, indicating that no `std::shared_ptr` instances own the object anymore, 
the object is automatically deleted and the memory is freed.



# Control Block

The control block is an internal data structure associated with each `std::shared_ptr` instance.
It contains the necessary information to manage the shared ownership of the object.
The control block typically consists of the following components:

## Reference Count:
- The reference count is an integer value that keeps track of the number of `std::shared_ptr` instances that share ownership of the object.
- Each time a new `std::shared_ptr` is created or an existing one is copied, the reference count is incremented.
- When a `std::shared_ptr` goes out of scope or is reset, the reference count is decremented.
- If the reference count reaches zero, it means that no `std::shared_ptr` instances own the object, and it can be safely deleted.
- **Reference counting is typically implemented using atomic operations to ensure thread safety.**

## Managed Object Pointer:
- The managed object pointer is a raw pointer that points to the dynamically allocated object being managed.
- It allows the `std::shared_ptr` to access and manipulate the object's contents.

## Deleter Function Pointer (optional):
- The deleter function pointer is an optional component that specifies a custom deleter function to be called when the object is deleted.
- It allows customization of the cleanup process, such as releasing additional resources associated with the object.

```
+------------------------+
| Control Block          |
|                        |
| +------------------+   |
| | Reference Count  |   |
| +------------------+   |
| | Managed Object   |   |
| | Pointer          |   |
| +------------------+   |
| | Deleter Function |   |
| | Pointer (optional)|  |
| +------------------+   |
+------------------------+
```

## Multiple `std::shared_ptr` instances can share the same control block.
When a `std::shared_ptr` is created, a control block is also created and associated with it.
Multiple `std::shared_ptr` instances can share the same control block if they are created from the same original `std::shared_ptr` or by copying each other.

## The control block is responsible for deleting the managed object and freeing the associated memory.
The reference count is incremented and decremented as `std::shared_ptr` instances are created, copied, or destroyed.
When the reference count reaches zero, the control block is responsible for deleting the managed object and freeing the associated memory.


# Concurrent Updates to the `shared_ptr` itself (i.e. during reassigning or changing shared ownership) :

## Description
In a multi-threaded environment, if multiple threads concurrently modify the shared ownership of a `std::shared_ptr`, it can lead to race conditions.
The control block of `std::shared_ptr` which includes the reference count is thread-safe, meaning that you can safely create copies of a `shared_ptr` ;
which increments the reference count; from multiple threads.
However, this does not mean that you can update the `shared_ptr` itself (i.e., make it point to a new object) from multiple threads without external synchronization.

## Example
```cpp

    std::shared_ptr<int> ptr = std::make_shared<int>(42);

    // Thread 1
    std::thread t1([&]() {
        ptr = std::make_shared<int>(43);
    });

    // Thread 2
    std::thread t2([&]() {
        ptr = std::make_shared<int>(44);
    });

    t1.join();
    t2.join();
```

## Example:
```cpp

std::shared_ptr<int> sharedPtr = std::make_shared<int>(42);

   // Thread 1
   sharedPtr.reset(new int(24));

   // Thread 2
   sharedPtr.reset(new int(36));
```

## Data races or Memory Leak:
In this scenario, if both threads execute concurrently.
It can result in the
(1) `sharedPtr` being reset to different memory locations, leading to potential memory leaks.
or
(2) accessing invalid memory due to data races, which is undefined behavior in C++.

## Solution
To fix this, you would need to protect the assignments with a mutex or other synchronization primitive.

# Accessing a destroyed object while other threads still hold references:
If a `std::shared_ptr` is accessed by multiple threads concurrently, and one thread destroys the object while others are still holding references to it.
It can result in accessing a destroyed object, leading to undefined behavior.

## Example:
```cpp

   std::shared_ptr<int> sharedPtr = std::make_shared<int>(42);

   // Thread 1
   sharedPtr.reset();

   // Thread 2
   int value = *sharedPtr; // Accessing a destroyed object
```
## Undefined behavior:
In this case, if Thread 2 tries to access the object pointed to by `sharedPtr` after it has been reset by Thread 1, it will result in undefined behavior.

## Solution:
To prevent this issue, you need to ensure proper synchronization and lifetime management.
One approach is to use additional synchronization mechanism, such as mutexes or condition variables.
Coordinate the destruction of the shared object among threads to ensure that no thread is accessing a destroyed object.


# Circular References or Circular dependencies:

    While this is not specific to multithreaded environments, it's a common pitfall with `std::shared_ptr` that can also cause issues in multithreaded code.
    If you have two objects that hold `shared_ptr` to each other, you have a circular reference;
    and the reference count for each object will never reach zero, causing a memory leak.
    A circular dependency occurs when two or more objects hold `std::shared_ptr` references to each other, preventing them from being destroyed.
    This can result in a memory leak because the reference counts of these objects never reach zero.
    To avoid this, you can break the circular dependency by using `std::weak_ptr` or other alternatives.

## Example:
- Order Book Management:
    In a trading platform, the order book contains information about buy and sell orders for various financial instruments.
    The order book may have complex data structures, such as linked lists or trees, where `std::shared_ptr` is used to manage the memory of the nodes.
    If a circular dependency exists between these nodes, it can lead to memory leaks and prevent the proper deallocation of memory.
    This can impact the efficiency and stability of the trading platform.

- Trade Execution and Settlement:
    When executing trades and settling transactions, multiple objects may be involved, such as trade orders, trade execution reports, and settlement records.
    These objects may have interdependencies, and incorrect usage of `std::shared_ptr` can lead to circular dependencies.
    For example,
    a trade order may hold a `std::shared_ptr` reference to a trade execution report, while the trade execution report holds a `std::shared_ptr` reference to the trade order.
    This circular dependency can prevent the proper destruction of these objects and lead to memory leaks.


```cpp
#include <iostream>
#include <memory>

class B; // Forward declaration

class A
{
public:
    std::shared_ptr<B> bSharedPtr; // Declare a shared pointer to B
};

class B
{
public:
    std::shared_ptr<A> aSharedPtr; // Declare a shared pointer to A
};

int main()
{
    std::shared_ptr<A> aSharedPtr = std::make_shared<A>();
    std::shared_ptr<B> bSharedPtr = std::make_shared<B>();

    aSharedPtr->bSharedPtr = bSharedPtr; // Assign the shared pointer to B
    bSharedPtr->aSharedPtr = aSharedPtr; // Assign the shared pointer to A

    return 0;
}
```

In this example, we have two classes `A` and `B` that have a circular dependency.
`A` holds a `std::shared_ptr<B>` and `B` holds a `std::shared_ptr<A>`.
This creates a circular reference, where each object holds a shared pointer to the other.

The `main()` function creates `std::shared_ptr` instances of `A` and `B`.
We assign these instances to the respective shared pointers in `A` and `B` using the `shared_ptr` assignment.

## Memory Leak:
Circular reference using `shared_ptr` can lead to a memory leak.
The reference count of the objects will never reach zero because each `shared_ptr` keeps the reference count non-zero.
This prevents the objects from being deallocated, resulting in memory leaks.

## Solution (weak pointer):
To resolve this issue, you can use `std::weak_ptr` for back-references or secondary references that don't need to keep the object alive.
A `std::weak_ptr` allows you to access an object if it exists but doesn't increment the reference count.
This way, when the last `std::shared_ptr` to an object is destroyed, the object will be cleaned up, even if there are still `std::weak_ptr`s pointing to it.

``` cpp

#include <iostream>
#include <memory>

class B; // Forward declaration

class A
{
public:
    std::weak_ptr<B> bWeakPtr; // Declare a weak pointer to B

    void doSomething()
    {
        std::shared_ptr<B> bSharedPtr = bWeakPtr.lock(); // Attempt to lock the weak pointer

        if (bSharedPtr) // Check if the object is still valid
        {
            std::cout << "Doing something with B\n";
        }
        else
        {
            std::cout << "B no longer exists\n";
        }
    }
};

class B
{
public:
    std::weak_ptr<A> aWeakPtr; // Declare a weak pointer to A
};

int main()
{
    std::shared_ptr<A> aSharedPtr = std::make_shared<A>();
    std::shared_ptr<B> bSharedPtr = std::make_shared<B>();

    aSharedPtr->bWeakPtr = bSharedPtr; // Assign the shared pointer to the weak pointer in A
    bSharedPtr->aWeakPtr = aSharedPtr; // Assign the shared pointer to the weak pointer in B

    aSharedPtr->doSomething(); // A tries to access B through the weak pointer

    bSharedPtr.reset(); // Reset the shared pointer to B

    aSharedPtr->doSomething(); // A tries to access B again

    return 0;
}
```

In this example, we have two classes A and B that have a circular dependency.
A holds a std::weak_ptr<B> and B holds a std::weak_ptr<A>.
This weak pointer usage breaks the circular reference, allowing the objects to be deallocated properly.

In the doSomething() member function of A, we attempt to lock the std::weak_ptr<B> using the lock() function.
This returns a std::shared_ptr<B> if the object is still valid, or an empty std::shared_ptr otherwise.

We then check if the std::shared_ptr<B> is valid (not empty).
If it is, we can safely perform operations with B.
If it is not, it means that B no longer exists, and we handle that case accordingly.

In the main() function, we create std::shared_ptr instances of A and B.
We assign these instances to the respective weak pointers in A and B using the shared_ptr assignment.

After that, we call the doSomething() function of A, where it attempts to access B through the weak pointer.
Since B is still valid, the output will be "Doing something with B".

Then, we reset the shared pointer to B using reset(), which effectively releases ownership of the object.
After resetting, B is no longer valid.

Finally, we call doSomething() again, where A attempts to access B.
Since B no longer exists, the output will be "B no longer exists".

This example demonstrates how std::weak_ptr can be used to break a circular reference and handle scenarios where objects may have been deleted.
It allows you to safely access the object through the weak pointer without causing undefined behavior.

# Incorrect usage with raw pointers:
If you mix `std::shared_ptr` with raw pointers and accidentally delete the object managed by the shared pointer;
It can result in a use-after-free error or undefined behavior.

## Example:
   ```cpp

   int* rawPtr = new int(42);
   std::shared_ptr<int> sharedPtr(rawPtr);

   // ...

   delete rawPtr; // Incorrectly deleting the object

   // Accessing sharedPtr now results in undefined behavior
   ```

To avoid this, always use `std::shared_ptr` consistently and avoid manually deleting the objects managed by shared pointers.


# Inappropriate use in performance-critical code:
While `std::shared_ptr` provides convenience and safety, it comes with some performance overhead due to reference counting and thread safety mechanisms.
In performance-critical code where the overhead of `std::shared_ptr` is a concern, using alternatives like `std::unique_ptr`
or custom memory management techniques might be more appropriate.

`std::shared_ptr` provides convenience and safety by managing the lifetime of dynamically allocated objects through reference counting. 
However, this convenience comes at a cost in terms of both space and time.

## Space Overhead:
   - `std::shared_ptr` requires additional memory to store the reference count and a control block associated with the managed object. 
     The control block contains the reference count, a weak reference count, and any custom deleters or allocators.
   - The reference count keeps track of the number of `shared_ptr` instances that share ownership of the object. 
     This allows the object to be deallocated when the reference count reaches zero.
   - The weak reference count is used by `std::weak_ptr` to determine if the object is still alive or has been deleted.
   - The control block also stores custom deleters or allocators if provided, increasing the memory overhead.

## Time Overhead:
   - Every time a `shared_ptr` is copied or assigned, the reference count is incremented. 
     When a `shared_ptr` goes out of scope or is explicitly reset, the reference count is decremented. 
     This atomic increment and decrement operations can introduce synchronization overhead in multi-threaded scenarios.
   - The reference count must be accessed and modified atomically to ensure thread safety, 
     which adds additional overhead compared to raw pointers or other smart pointers that do not require atomic operations.
   - Additionally, the dynamic memory allocation and deallocation performed by `std::shared_ptr` can introduce performance overhead 
     compared to other smart pointers or raw pointers that do not involve dynamic memory management.

## Comparison with other managed pointers and raw pointers:
###  std::unique_ptr:
   - `std::unique_ptr` is a lightweight smart pointer that manages the lifetime of a single object. 
     It does not have the overhead of reference counting or thread safety mechanisms.
   - `std::unique_ptr` is typically used when exclusive ownership is required, and it provides better performance compared to `std::shared_ptr` in performance-critical code.
   - However, `std::unique_ptr` cannot be easily shared or transferred between different parts of the code, as it enforces exclusive ownership.

### Raw Pointers:
   - Raw pointers do not have the overhead of reference counting or thread safety mechanisms.
   - However, raw pointers do not manage the lifetime of objects automatically.
     It becomes the responsibility of the programmer to manually allocate and deallocate memory,
        which can lead to memory leaks or dangling pointer issues if not handled correctly.
   - Raw pointers also do not provide the safety and convenience features of smart pointers, 
     such as automatic deallocation and exception safety.

# Misuse of custom deleters:
``std::shared_ptr` allows you to provide custom deleters to handle the destruction of the managed object.
If the custom deleter is not implemented correctly or misused, it can result in memory leaks, double deletions, or other undefined behavior.
Ensure that custom deleters are implemented properly and handle the destruction of the object correctly.
## Example:
Suppose we have a `Trade` class that represents a trade executed in the trading platform.
The `Trade` class has a member variable `tradeData`, which is a dynamically allocated object of type `TradeData`.
The `TradeData` class contains the actual data related to the trade.

```cpp
class TradeData
{
public:
    TradeData(const std::string& symbol, double price)
    : symbol_(symbol)
    , price_(price) {}
    // ...
private:
    std::string symbol_;
    double price_;
    // ...
};

class Trade
{
public:
    Trade(const std::string& symbol, double price)
    : tradeData_(new TradeData(symbol, price)) {}
    // ...
private:
    std::shared_ptr<TradeData> tradeData_;
    // ...
};
```

Now, let's look at the potential issues that can arise due to the misuse of `std::shared_ptr` deleters:

### Memory Leak:
If a custom deleter is not implemented correctly or omitted, it can result in a memory leak.
Let's say we have a custom deleter that is responsible for freeing the memory of the `TradeData` object.
However, due to a mistake, we forgot to provide the custom deleter when constructing the `std::shared_ptr`. 

```cpp
class Trade
{
public:
    Trade(const std::string& symbol, double price)
        : tradeData_(new TradeData(symbol, price),
        [](TradeData* data)
        {
            delete data; /* Incorrect deleter */
        }) {}
    // ...
};
```

In this case, when the `std::shared_ptr` goes out of scope, the default deleter will be used, which is `delete`.
Since the `TradeData` object was allocated with `new`, but the default `delete` operator is used instead of the custom deleter, it leads to a memory leak.
The memory allocated for the `TradeData` object is not properly released.

The deleter function in the `std::shared_ptr` constructor is incorrect.
In the deleter function, it is generally not recommended to delete the managed object itself.
Instead, the deleter function should be responsible for cleaning up any dynamically allocated dependencies or resources associated with the object.

The corrected code for the `std::shared_ptr` constructor with a proper deleter function:

```cpp
tradeData_(new TradeData(symbol, price),
        [](TradeData* data)
        {
            // Delete or reset any dynamically allocated dependencies or resources here
            // For example:
            delete data->dependency;
            // Or:
            data->dependency.reset();

            delete data; // Now it is safe to delete the managed object itself
        })
```

### Undefined Behavior:
If a custom deleter is misused or incorrectly implemented, it can result in other forms of undefined behavior.
For example, consider a scenario where the custom deleter tries to access a member variable of the `Trade` class:

```cpp
class Trade
{
public:
    Trade(const std::string& symbol, double price)
        : tradeData_(new TradeData(symbol, price),
        [](TradeData* data)
        {
            delete data;
            /* Accessing `Trade` object here */
        }) {}
    // ...
};
```
# The corner cases when initializing a `std::shared_ptr` using `new`.

## Initializing `std::shared_ptr` using `new`:
   When initializing a `std::shared_ptr` using `new`, there are a few corner cases to consider:

### Single-threaded environment:
#### Exception thrown during the construction:
    In a single-threaded environment, initializing a `std::shared_ptr` using `new` can lead to issues if an exception is thrown during the construction of the managed object.

##### Example:

      ```cpp
      #include <iostream>
      #include <memory>

      class MyClass
      {
      public:
          MyClass()
          {
              std::cout << "MyClass constructor\n";
              throw std::runtime_error("Exception during construction");
          }

          ~MyClass()
          {
              std::cout << "MyClass destructor\n";
          }
      };

      int main()
      {
          try
          {
              std::shared_ptr<MyClass> ptr(new MyClass());
          }
          catch (const std::exception& e)
          {
              std::cout << "Exception caught: " << e.what() << '\n';
          }

          return 0;
      }
      ```

      In this example, the `MyClass` constructor throws an exception.
      As a result, the destructor is not called, and the memory allocated by `new` is not deallocated.
      This leads to a memory leak.
##### Memory Leak:
    If an exception occurs, the object may not be properly deallocated, leading to a memory leak.

### Multi-threaded environment:
    In a multi-threaded environment, initializing a `std::shared_ptr` using `new` can lead to issues;
    if multiple threads attempt to access and modify the same `shared_ptr` concurrently. 
    This can result in race conditions and undefined behavior.

#### Example:

      ```cpp
      #include <iostream>
      #include <memory>
      #include <thread>

      void threadFunc(std::shared_ptr<int>& ptr)
      {
          for (int i = 0; i < 1000000; ++i)
          {
              std::shared_ptr<int> localPtr = ptr;
              ++(*localPtr);
          }
      }

      int main()
      {
          std::shared_ptr<int> ptr(new int(0));

          std::thread t1(threadFunc, std::ref(ptr));
          std::thread t2(threadFunc, std::ref(ptr));

          t1.join();
          t2.join();

          std::cout << "Final value: " << *ptr << '\n';

          return 0;
      }
      ```

      In this example, two threads increment the value stored in the shared pointer concurrently. 
      This leads to a race condition where the reads and writes to the shared pointer are not synchronized. 
      As a result, the final value printed may not be the expected sum of increments due to the race condition.

## Impact when `new` throws:
    When `new` throws an exception during the construction of the managed object, it can have a significant impact on code execution.

### Single-threaded environment:
    In a single-threaded environment, if `new` throws an exception, it prevents the `std::shared_ptr` from being constructed,
    and the exception propagates up the call stack. This allows the programmer to handle the exception and take appropriate action.

### Multi-threaded environment:
    In a multi-threaded environment, if `new` throws an exception, it can have unpredictable effects. 
    The threads that have already acquired the shared pointer may continue executing with an incomplete or uninitialized object, 
    leading to undefined behavior and potential crashes or data corruption.

# `std::make_shared` instead of directly using `new` to initialize a `std::shared_ptr`.
## `std::make_shared` performs a single dynamic memory allocation for both the control block and the managed object.
    This reduces the potential for issues related to exception safety and improves performance.

### Using `new` with `std::shared_ptr`:
   In this case, when using `new` with `std::shared_ptr`, separate memory allocations are performed for the integer object and the control block.

```
Memory Diagram:

        +-----------------+       +-----------------+
ptr1 -->|  shared_ptr<>   |       |       int       |
        +-----------------+       +-----------------+
        | control block   |       |     memory      |
        +-----------------+       +-----------------+

```

    In the above diagram, `ptr1` is a `std::shared_ptr` that manages an `int` object created with `new`. 
    The control block, represented by the shared_ptr<> box, is a separate allocation that stores the reference count and other bookkeeping information. 
    The actual memory for the integer object is allocated separately.

### Using `std::make_shared`:
   When using `std::make_shared`, a single memory allocation is performed to store both the integer object and the control block.

```
Memory Diagram:

        +-----------------+
ptr2 -->|  shared_ptr<>   |
        +-----------------+
        | control block   |
        |    +--------+   |
        |    |  int   |   |
        |    +--------+   |
        +-----------------+

```

In this diagram, `ptr2` is a `std::shared_ptr` that manages an `int` object created with `std::make_shared`. 
The control block, represented by the shared_ptr<> box, is allocated together with the memory for the integer object. 
This combines both the object and control block into a single allocation, improving efficiency and reducing memory overhead.

It's important to note that the control block stores the reference count and other necessary information for managing the shared ownership of the object. 
### Conclusion:`std::make_shared` reduces the overall memory usage and provides better performance
    By combining the control block and object memory in a single allocation, `std::make_shared` reduces the overall memory usage and provides better performance.
